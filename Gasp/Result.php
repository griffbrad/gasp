<?php

/**
 * Gasp
 *
 * @link https://github.com/griffbrad/gasp
 */

namespace Gasp;

use Gasp\Render\Summary;
use Gasp\Result\ResultInterface;
use Gasp\Terminal;

/**
 * This class should be used when returning the results of a single task.
 * Typically, you'll want to at least set a message and a status on the result
 * object.  Otherwise, gasp will assume that your task failed.
 */
class Result implements ResultInterface
{
    use SetOptions;

    /**
     * Use this status when the task succeeds.
     *
     * @const
     */
    const SUCCESS = 'success';

    /**
     * Use this status when something is potentially wrong, but you don't want
     * the task to fail completely.
     *
     * @const
     */
    const WARN = 'warn';

    /**
     * Use this status when the task has failed.  In many cases, this may also
     * be used to halt execution.
     *
     * @const
     */
    const FAIL = 'fail';

    /**
     * The summary message that should be displayed for the task.
     *
     * @var string
     */
    private $message = '<no message available>';

    /**
     * A terminal instance that can be used for special output when running
     * interactively.
     *
     * @var Terminal
     */
    private $terminal;

    /**
     * The status of the task after execution.
     *
     * @var string
     */
    private $status = self::FAIL;

    /**
     * Any output generated by the task.
     *
     * @var string
     */
    private $output = '';

    /**
     * Set multiple options on the result at once.
     *
     * @param array $options
     */
    public function __construct(array $options = array())
    {
        $this->setOptions($options);
    }

    /**
     * Display this result.  Includes the summary and any command output.
     *
     * @return string
     */
    public function display()
    {
        return $this->getSummary() . $this->getOutput();
    }

    /**
     * Set the terminal instance that can be used for special output formatting.
     *
     * @param Terminal $terminal
     * @return $this
     */
    public function setTerminal(Terminal $terminal)
    {
        $this->terminal = $terminal;

        return $this;
    }

    /**
     * Get terminal instance for special formatting.
     *
     * @return Terminal
     */
    public function getTerminal()
    {
        if (!$this->terminal) {
            $this->terminal = new Terminal();
        }

        return $this->terminal;
    }

    /**
     * Get a summary of this result.  The summary will display the status and
     * the message.
     *
     * @return string
     */
    public function getSummary()
    {
        return (string) new Summary($this);
    }

    /**
     * Set a short message explaining the result of executing the task.
     *
     * @param $message
     * @return $this
     */
    public function setMessage($message)
    {
        $this->message = $message;

        return $this;
    }

    /**
     * Get a summary message for this result.
     *
     * @return string
     */
    public function getMessage()
    {
        return $this->message;
    }

    /**
     * Pass along any output generated while executing the task.  Can be a
     * string or an array of lines of output.
     *
     * @param mixed $output
     * @return $this
     */
    public function setOutput($output)
    {
        if (is_array($output)) {
            $output = implode(PHP_EOL, $output) . PHP_EOL;
        }

        $this->output = $output;

        return $this;
    }

    /**
     * Get the output generated during the task's execution.
     *
     * @return string
     */
    public function getOutput()
    {
        return $this->output;
    }

    /**
     * Set the status for the task.  We attempt to accommodate common
     * variations on the valid statuses (fail, warn, and success).
     *
     * @param string $status
     * @return $this
     * @throws Exception
     */
    public function setStatus($status)
    {
        $status = strtolower($status);

        if ('failure' === $status || 'failed' === $status) {
            $status = 'fail';
        } elseif ('warning' === $status) {
            $status = 'warn';
        }

        if (!$this->isValidStatus($status)) {
            throw new Exception("{$status} is not a valid status.");
        }

        $this->status = $status;

        return $this;
    }

    /**
     * Get the status for the task.
     *
     * @return string
     */
    public function getStatus()
    {
        return $this->status;
    }

    /**
     * Check to see if the task failed.
     *
     * @return boolean
     */
    public function isFailure()
    {
        return self::FAIL === $this->status;
    }

    /**
     * Check to see if the task resulted in a warning.
     *
     * @return boolean
     */
    public function isWarning()
    {
        return self::WARN === $this->status;
    }

    /**
     * Check to see if the task succeeded.
     *
     * @return boolean
     */
    public function isSuccess()
    {
        return self::SUCCESS === $this->status;
    }

    /**
     * Ensure the supplied status value is valid.
     *
     * @param string $status
     * @return bool
     */
    private function isValidStatus($status)
    {
        switch ($status) {
            case self::SUCCESS:
            case self::WARN:
            case self::FAIL:
                return true;
            default:
                return false;
        }
    }
}
